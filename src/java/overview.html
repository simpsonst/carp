<body>

  These classes facilitate remote invocation of Java objects,
  primarily over REST-like calls.

  The goals are as follows:

  <ul>
    <li>
      <p>
	Have an IDL from which target-specific code can be generated.

	For Java specifically, the code should be generated by an
	annotation processor, so it is available within the same code
	base that defines it.
      </p>
    </li>

    <li>
      <p>
	Allow client-side developers familiar with REST to be able to
	craft code manually.

	It should be enough to fling together a JSON message in an
	HTTP request, and process the JSON message in the response.
      </p>
    </li>

    <li>
      <p>
	Allow server-side developers to present a persistent hierarchy
	of components in the URI virtual-path space.

	If the server returns a reference to a component identified by
	(say) a UUID, that UUID should appear in its virtual path, and
	the client should be able to retain its URI indefinitely, and
	expect to find the component as soon as it tries accessing it
	again.
      </p>
    </li>
  </ul>

  <p>
    An Interface Definition Language (IDL) is defined, from which
    source code in Java and potentially other languages can be
    generated.

    The types are also summarized as Java property files, which are
    placed in the generated classpath.

    Other projects that define their own IDLs can reference these
    files without requiring the referenced project's source.
  </p>

  <p>
    An annotation processor generates Java source code, which can
    therefore be available dynamically in the editor, without a prior
    IDL-compilation step.

    Only the essential classes required for completing compilation are
    generated.

    Code to implement proxies to remote objects and exposure of
    interfaces is static, and engaged only at run time.
  </p>

  <p>
    A runtime library reads properties in the classpath and
    annotations on the generated classes to provide proxies for remote
    objects based on their interface types, and to expose such objects
    to remote invocation.

    A server can set up agents for indexed components and
    sub-components, so that they are bound to paths containing their
    indexed identities.

    If a client retains a URI to an indexed component, and then tries
    to access it, the component need not exist at the server, and will
    instead be generated on the client's demand, and discarded if not
    used for some time.
  </p>

  {@h1 IDL syntax and mapping}

  <p>
    An IDL file defines a complete module, consisting of imports and
    type definitions.
  </p>

  {@h2 Element names}

  <p>
    All names referenced in an IDL follow a format defined by {@link
    uk.ac.lancs.carp.map.ExternalName}, and look something like a
    fully qualified Java package name
    (<code>acme.battleships.mgmt</code>, for example).

    Such names consist of several dot-separated components, with each
    component being a series of words, separated by either dashes or
    slashes.

    Names are case-insensitive, but normalized to lower-case.
  </p>

  <p>
    Names with only one component are <dfn>leaf names</dfn>.

    Otherwise, they are <dfn>fully qualified</dfn>.

    The <dfn>prefix</dfn> of a fully qualified name is the name
    obtained by removing the last component.
  </p>

  <p>
    Every IDL module has a name.

    All names defined in an IDL must be leaf names.

    The names of types defined in an IDL have a <dfn>short name</dfn>
    (the one used in its definition, which is necessarily a leaf
    name), and a long name, obtained by prefixing the short name with
    the module's name and a dot, and so is necessarily a fully
    qualified name.

    Names for enumeration constants and field/parameter names must be
    leaf names.
  </p>

  <p>
    When IDLs are compiled to a target language, names within them are
    translated two-fold.

    First, the module prefix may be mapped to another, user-defined
    prefix specific to the target language (e.g., a Java package), so
    different languages may map the same IDL module to different
    target-specific nodes of their naming hierarchies.

    Second, a name may be mapped in several target-specific ways
    according to the needs or conventions of the target language.

    For example, the IDL module <code>acme.battleships</code> might be
    mapped to the Java package <code>com.acme.battleships</code> (as
    specified by the {@link uk.ac.lancs.carp.deploy.Deploy}
    annotation).

    An interface type within it,
    (say) <code>acme.battleships.board</code>, would then translate to
    the Java interface type <code>com.acme.battleships.Board</code>.
  </p>

  <p>
    Dashes normally separate words in the same component, but slashes
    can be used to imply a different mapping.

    So if <code>acme.battleships.ship-type</code> refers to a type,
    the Java name will end with <code>ShipType</code>.

    If it refers to a constant, the Java name will end
    with <code>SHIP_TYPE</code>.

    Instead of a dash, the use of a slash will yield recapitalization
    for Java class and method names, but will not imply an underscore
    in constants.

    This is useful for abbreviations, such as <code>i/e/t/f</code>,
    for which a mapping to <code>Ietf</code> for a class name, or
    to <code>I_E_T_F</code> for a constant, might be undesirable.
  </p>

  <p>
    These rules avoid forcing Java package naming conventions on other
    languages targeted by IDL compilation.
  </p>

  {@h2 Imports}

  <p>
    Imports serve only to resolve short type names into fully
    qualified names that include the module they belong to.

    A module may refer to types it defines itself by their short
    names.

    A simple import looks like this:
  </p>

  <pre>
import acme.battleship.coords;</pre>

  <p>
    This permits the type <code>acme.battleship.coords</code> to be
    referred to as simply <code>coords</code> within the containing
    module definition.

    A type may be locally renamed:
  </p>

  <pre>
import acme.battleship.coords as coordinates;</pre>

  <p>
    â€¦allowing it to be referred to locally
    as <code>coordinates</code>.

  <p>
    (Technically, a type definition using a reference type also
    creates an alias, but might be less convenient than an import with
    an <code>as</code> clause, as means both names are visible in the
    scope of the module, which could lead to naming collisions.

    The original name might also be cumbersome to type, and
    an <code>as</code> clause allows it to be referenced only once.)
  </p>




  {@h2 Type definitions}

  <p>
    Types are defined with:
  </p>

  <pre>
type <var>leaf-name</var> <var>type-specification</var>;</pre>

  <p>
    Possible type specifications are defined below.

  <p>
    Enumeration types, structure types and interface types must only
    appear as the type specification of a type definition (not as an
    anonymous type) to be used from Java, as each of these is
    translated into a Java class, whose name is derived from the
    definition's leaf name.
  </p>
  

  {@h2 Type specifications}

  {@h3 Integer types}

  <p>
    An integer type has optional upper and lower bounds, which may be
    zero, positive or negative.

    Expressions of the following kind are permitted:
  </p>

  <table summary="This table shows example integer type expressions alongside their mathematical meaning.">
    <thead>
      <tr><th>Example syntax</th> <th>Allowed values</th></tr>
    </thead>

    <tbody>
      <tr><td><code>1..20</code></td>
	<td>&#x2124; &#x2229; [1,20]</td></tr>

      <tr><td><code>1...</code></td>
	<td>&#x2124; &#x2229; [1,+&infin;] </td></tr>

      <tr><td><code>..20</code></td>
	<td>&#x2124; &#x2229; [-&infin;,20]</td></tr>

      <tr><td><code>...</code></td> <td>&#x2124;</td></tr>
    </tbody>
  </table>

  <p>
    In Java, integer types are represented with {@link
    java.math.BigInteger}, {@code long}, {@code int}, {@code short} or
    {@code byte}, or their boxed equivalents.
  </p>



  {@h3 Real types}

  <p>
    A real type is represented with a dot followed by a positive
    integer, indicating decimal digits of precision.
  </p>

  <p>
    In Java, integer types are represented with {@link
    java.math.BigDecimal}, {@code double} or {@code float}, or their
    boxed equivalents.
  </p>


  {@h3 Built-in types}

  <p>
    A virtual module <code>built-in</code> is defined.

    A built-in string type called <code>built-in.string</code> is
    defined to map to {@link String} in Java.

    A built-in UUID type called <code>built-in.uuid</code> is
    defined to map to {@link java.util.UUID}.

    A built-in Boolean type called <code>built-in.boolean</code> is
    defined to map to {@code boolean}/{@link Boolean}.

    The following integer types are also defined:
  </p>

  <table summary="This table lists built-in types against their explicit equivalents.">
    <thead>
      <tr><th>Alias</th> <th>Type</th></tr>
    </thead>
    <tbody>
      <tr><td><code>built-in.uint8</code></td> <td><code>0..255</code></td></tr>
      <tr><td><code>built-in.uint16</code></td> <td><code>0..65536</code></td></tr>
      <tr><td><code>built-in.uint32</code></td> <td><code>0..4294967295</code></td></tr>
      <tr><td><code>built-in.uint64</code></td> <td><code>0..18446744073709551615</code></td></tr>
      <tr><td><code>built-in.int8</code></td> <td><code>-128..127</code></td></tr>
      <tr><td><code>built-in.int16</code></td> <td><code>-32768..32767</code></td></tr>
      <tr><td><code>built-in.int32</code></td> <td><code>-2147483648..2147483647</code></td></tr>
      <tr><td><code>built-in.int64</code></td> <td><code>-9223372036854775808..9223372036854775807</code></td></tr>
    </tbody>
  </table>

  <p>
    For each of the built-in types, the leaf automatically acts as a
    short name, unless a module defines a type or an import for the
    short name.
  </p>


  {@h3 Reference types}

  <p>
    A reference type is simply the name of the type.

    If the type is defined in the same module as the reference, the
    short name may be used.

    If the type is imported, the short name may be used.

    Otherwise, the long name must be used.
  </p>

  <p>
    The Java equivalent of a reference type depends on what it refers
    to.

    If the referenced type is an enumeration, structure or interface
    type, the Java equivalent is the corresponding Java class name of
    the referenced type.

    Otherwise, the reference type is represented in Java by what the
    reference resolves to.
  </p>



  {@h3 Enumeration types}

  <p>
    An enumeration type is a space-separated list of leaf names,
    delimited by <code>&lt;</code> and <code>&gt;</code>.

    For example:
  </p>

  <pre>
type ship-type &lt;aircraft-carrier battleship cruiser submarine destroyer&gt;;</pre>

  <p>
    In Java, this translates to the following:
  </p>

  <pre>
public enum ShipType {
  SUBMARINE,
  BATTLESHIP,
  DESTROYER,
  CRUISER,
  AIRCRAFT_CARRIER,
}</pre>

  <p>
    An enumeration type must be named to be usable from Java.
  </p>

  <p>
    No guarantee is made about the ordering of constants.
  </p>



  {@h3 Map types}

  <p>
    A map type is expressed as two type specifications joined
    by <code>-&gt;</code>.

    For example:
  </p>

  <pre>
type score-table string -&gt; 0...;</pre>

  <p>
    In Java, this is expressed as the following:
  </p>

  <pre>
{@linkplain java.util.Map Map}&lt;{@linkplain String String}, {@linkplain java.math.BigInteger BigInteger}&gt;</pre>

  <p>
    Associativity is right-to-left.

    Parentheses may be used to indicate more complex associations.

    <code>a-&gt;b-&gt;c</code> is equivalent
    to <code>a-&gt;(b-&gt;c)</code>.
  </p>

  <p>
    Note that no Java class declaration is generated for a map type.
  </p>




  {@h3 Sequence types}

  <p>
    A sequence type is expressed as a type specification preceded by
    an asterisk (U+002A <samp>*</samp>).

    For example, a sequence of integers in the range [0, 40000] is
    declared as:
  </p>

  <pre>
*0..40000</pre>

  <p>
    In Java, this is expressed as the following:
  </p>

  <pre>
{@linkplain java.util.List List}&lt;{@linkplain Integer}&gt;</pre>

  <p>
    Note that no Java class declaration is generated for a sequence
    type.
  </p>
  
    

  {@h3 Set types}

  <p>
    A set type is expressed as a type specification preceded by an
    ampersand (U+0026 <samp>&amp;</samp>).

    For example, a set of integers in the range [-1000, 40000] is
    declared as:
  </p>

  <pre>
&amp;-1000..40000</pre>

  <p>
    In Java, this is expressed as the following:
  </p>

  <pre>
{@linkplain java.util.Collection Collection}&lt;{@linkplain Integer}&gt;</pre>

  <p>
    However, if the element type is an integer with a non-strict
    subrange of [0,2<sup>31</sup>), {@link java.util.BitSet} will be
    used instead.
  </p>

  <p>
    Note that no Java class declaration is generated for a set type.
  </p>



  {@h3 Structure types}

  <p>
    A structure type is delimited by braces, and consists of field groups.

    Each field group consists of a comma-separated list of field
    names, a colon, and a type specification.

    Each field name may be suffixed by a question mark
    (U+003F <samp>?</samp>), denoting an optional field.

    Field groups are separated by semicolons; the last group may also
    be terminated by a semicolon.

    A structure type must be named to be usable in Java.
  </p>

  <p>
    The following declaration defines a structure type
    called <samp>coords</samp>, with two fields <samp>x</samp>
    and <samp>y</samp>, taking integers in the range [1,20]:
  </p>

  <pre>
type coords {
  x, y : 1..20;
};</pre>

  <p>
    This type translates to the following Java declaration:
  </p>

  <pre>
public final class Coords {
  public boolean equals(Object obj);

  public int hashCode();

  public int x();

  public static Builder x(int x);

  public int y();

  public static Builder y(int y);

  public static class Builder {
    public Builder x(int x);

    public Builder y(int y);
  }
}</pre>

  <p>
    This in turn allows the user to build such an object and access it
    with the likes of:
  </p>

  <pre>
Coords c = Coords.x(20).y(15).$done();
System.out.printf("(%d, %d)%n", c.x(), c.y());</pre>
  


  {@h3 Interface types}

  <p>
    An interface type is delimited by <code>[</code> and <code>]</code>, and
    consists of call specifications and inheritances.
  </p>

  <p>
    Each call specification consists of <code>call</code>, a leaf
    name, optional arguments (matching the syntax of a structure
    type), and optional response types.

    Each response type consists of <code>=&gt;</code>, a leaf name,
    and optional arguments (again, matching the syntax of a structure
    type).
  </p>

  <p>
    An inheritance consists of <code>inherit</code>, a type
    specification (which must be a reference to an interface type),
    and a semicolon.

  <p>
    An interface type must be named to be usable in Java.
  </p>

  <p>
    For example, this interface type has two calls, <code>shoot</code>
    and <code>dummy</code>:
  </p>

  <pre>
type board [
  call shoot { at : coords }
  =&gt; miss
  =&gt; hit
  =&gt; sink
    { kind : ship-type };
  call dummy;
];</pre>

  <p>
    <code>dummy</code> has no arguments, and no responses, so calling
    it may return before the call has completed.

    <code>shoot</code> has one argument, and will produce one of three
    responses, one of which has an argument of its own.

    If you want a synchronous return with no data, the convention is
    to define a single, zero-argument response type
    called <samp>okay</samp>.
  </p>

  <p>
    The example translated into Java as:
  </p>

  <pre>
public interface Board {
  void dummy();

  Shoot shoot(Coords at);

  class Shoot {
    public Hit hit();

    public static final class Hit {
      public static final class Builder {
      }
    }

    public Miss miss();

    public static final class Miss {
      public static final class Builder {
      }
    }

    public Sink sink();

    public static final class Sink {
      public final ShipType kind();

      public static final class Builder {
        public Builder kind(ShipType kind);
      }

      public static Builder kind(ShipType kind);
    }
  }
}</pre>

  <p>
    Each inheritance is translated into an item on
    an <code>extends</code> clause.
  </p>

  <p>
    If you have a reference to a <code>Board</code>, you can write:
  </p>

  <pre>
Board b = <var>...</var>;
b.dummy();
Board.Shoot result = b.shoot(Coords.x(10).y(15).$done());
switch (result.$type()) {
case HIT:
  System.out.printf("A hit!%n");
  break;
case MISS:
  System.out.printf("A miss :-(%n");
  break;
case SINK:
  System.out.printf("You sunk a %s!%n", result.sink().kind());
  break;
}</pre>


  {@h1 Build environment}

  <p>
    First, make sure your annotation processor path
    includes the following:
  </p>

  <ul>
    <li><a href="https://scc-forge.lancaster.ac.uk/open/simpsons/software/pkg-lusyn"><samp>lusyn.jar</samp></a>
    <li><samp>javax.json.jar</samp>
    <li><samp>carp_annot.jar</samp>
    <li><samp>carp_syntax.jar</samp>
    <li><samp>carp_model.jar</samp>
    <li><samp>carp_modelsyn.jar</samp>
    <li><samp>carp_aproc.jar</samp>
  </ul>

  <p>
    Your compile-time class path must include:
  </p>

  <ul>
    <li><samp>httpcore.jar</samp> from Apache
    <li><samp>httpclient.jar</samp> from Apache
    <li><samp>carp_annot.jar</samp>
    <li><samp>carp_core.jar</samp>
  </ul>

  <p>
    A module's fully qualified name is determined by its location in
    the source path.

    For example, to define a module
    called <samp>acme.battleships.mgmt</samp>, place its IDL
    definitions in the
    file <samp>acme/battleships/mgmt/carp.rpc</samp> in the source
    path.

    You can also put the IDL file in the class path, if the IDL file
    is external to your project.

    The source path will be searched first.
  </p>

  <p>
    To create the essential Java classes supporting a module, choose
    the Java package that the module will map to,
    say, <code>org.acme.battleships</code>, and annotate the package
    in <samp>com/acme/battleships/package-info.java</samp>:
  </p>

  <pre>
&#64;{@linkplain uk.ac.lancs.carp.deploy.Deploy uk.ac.lancs.carp.deploy.Deploy}("acme.battleships.mgmt")
package com.acme.battleships;</pre>

  <p>
    If you compile with OpenJDK or NetBeans, the generated classes
    should be available before you use them.

    Eclipse has two problems, however.

    One, it won't process annotations on package declarations
    in <samp>package-info.java</samp>, but you can get round that by
    putting the annotation on a class in the desired package.

    Two, Eclipse doesn't provide {@link
    javax.tools.StandardLocation#SOURCE_PATH} or {@link
    javax.tools.StandardLocation#CLASS_PATH} to the annotation
    processors it runs.

    I never got very far with IntelliJ IDEA, but it seemed to have no
    annotation processing while editing.
  </p>


  {@h1 Creating a presence}

  <p>
    All invocation of remote interfaces or exposure of local
    interfaces to remote execution must be done through
    a <dfn>presence</dfn>.

    A presence can be for outgoing calls only (a client presence),
    incoming calls only (a server presence), or both (duplex).

    A duplex presence is recommended anyway, as any interface
    reference passed as an out parameter would have to be served as a
    callback.

    You can create one like this:
  </p>

  <pre>
{@linkplain java.net.URI} base = URI.create("http://localhost:8765/");
{@linkplain uk.ac.lancs.carp.LongestPrefixDispatcher} dispatcher = new LongestPrefixDispatcher(base);
{@linkplain uk.ac.lancs.carp.Presence} pres =
    Carp.start()
        .with(Carp.PLACEMENT, dispatcher.register("/"))
        .with(Carp.CLIENTS, HttpClients::createDefault)
        .build();</pre>

  <p>
    <code>HttpClients::createDefault</code> tells the presence how to
    create HTTP requests so it can act as a CARP client.

    You might want something more sophisticated, e.g., to add an SSL
    context so you can talk to HTTPS servers, so see {@link
    org.apache.http.impl.client.HttpClients#custom()} for how to do
    that.
  </p>

  <p>
    If you need to serve any objects, you also need an HTTP server to
    listen for incoming calls, and invoke the right local object.

    <code>dispatcher.register("/")</code> tells the presence what URI
    prefix to use when exposing local interfaces to remote invocation.

    You can register at a lower point on the path hierarchy, and leave
    other paths for other uses.

    The dispatcher is used to configure the server:
  </p>

  <pre>
{@linkplain java.net.InetSocketAddress} self = Carp.getPeer(base);
HttpServer webServer =
    ServerBootstrap.bootstrap()
                   .setLocalAddress(self.getAddress())
                   .setListenerPort(self.getPort())
                   .setServerInfo("CARP/1.0")
                   .setSocketConfig(SocketConfig.DEFAULT
                                                .custom()
                                                .setTcpNoDelay(true)
                                                .build())
                   .setExceptionLogger((ex) -&gt; {
                       try {
                           throw ex;
                       } catch (ConnectionClosedException e) {
                           // Ignore.
                       } catch (Throwable t) {
                           t.printStackTrace(System.err);
                       }
                   }).setHandlerMapper(dispatcher)
                   .create();
webServer.start();</pre>

  <p>
    Look up {@link org.apache.http.impl.bootstrap.ServerBootstrap} for
    further options, like HTTPS support.
  </p>

  {@h1 Exposing an interface}
    
  <p>
    Now suppose you have an implementation of <code>Board</code> to expose.

    Choose the subpath under the base URI, and bind it to the presence
    under that path:
  </p>

  <pre>
Board myBoard = new Board() { <var>...</var> };
pres.bind("board", Board.class, myBoard);</pre>

  <p>
    This object is now available
    under <samp>http://localhost:8765/board</samp> (based on the
    example above).

    {@link uk.ac.lancs.carp.ServerPresence#expose(Class, Object)} will
    provide this URI, in case you need it as a first point of contact.
  </p>

  {@h2 Receiver retention}

  <p>
    A presence retains its receivers (such as <code>myBoard</code>
    passed to {@link uk.ac.lancs.carp.ServerPresence#bind(String,
    Class, Object)} above) strongly only for a short period after
    binding, reset after each use.

    The period is indeterminate, but is a matter of several seconds,
    which is usually long enough for clients receiving endpoints for
    temporarily generated receivers to call back.

    This allows servers to notionally contain thousands of endpoints
    following a set pattern, while only managing receivers for the
    fraction of them that have been recently used.

    First points of contact, however, should normally be held strongly
    by the application, to guarantee that they are not exposed to
    garbage collection.
  </p>

  {@h1 Invoking an interface}

  <p>
    Given the address of an exposed interface, you can generate a
    proxy to it through your presence:
  </p>

  <pre>
URI remoteLoc = <var>...</var>;
Board theirBoard = pres.elaborate(Board.class, remoteLoc);
  </pre>

  {@h1 Execution}

  <p>
    You need the following jars to execute:
  </p>

  <ul>
    <li><samp>javax.json.jar</samp>
    <li><samp>httpcore.jar</samp> from Apache
    <li><samp>httpclient.jar</samp> from Apache
    <li><samp>carp_annot.jar</samp>
    <li><samp>carp_core.jar</samp>
    <li><samp>carp_model.jar</samp>
    <li><samp>carp_rt.jar</samp>
  </ul>


  {@h1 Components}

  <p>
    If an object of interface type is passed in a call or response, it
    is converted into an endpoint URI, allowing library at the
    receiving end to transparenly convert it into a proxy.

    The URI is chosen as follows:
  </p>

  <ol>

    <li>If the object is a proxy, the URI for that proxy is transmitted.</li>

    <li>Otherwise, if the object is a local receiver bound using
    {@link uk.ac.lancs.carp.ServerPresence#bind(String, Class,
    Object)}, the path specified by that call is resolved against the
    presence's placement to yield its full URI.</li>

    <li>Otherwise, if the object is a local receiver created by an
    {@link uk.ac.lancs.carp.component.Agent, that agent will have
    internally bound the receiver to a path computed by the agent, and
    that path is resolved against the receiver's container's path to
    yield its full URI..</li>

    <li>Otherwise, the object is assigned a sub-path
    of <samp>anon/<var>random-uuid</var></samp>.</li>

  </ol>

  <p>
    An implementation of an interface can
    define <dfn>components</dfn>, receivers of a related type, and
    control how they are automatically placed in sub-paths of the
    receiver, which is referred to as their <dfn>container</dfn>.

    Components can be singletons or indexed, and are created on
    demand.

    An {@link uk.ac.lancs.carp.component.Agent} handles the life cycle
    of a singleton or an indexed family of components.

    Components can also define sub-components of their own, and so on.
  </p>

  <p>
    For example, if a container is bound to the
    path <samp>foo/bar</samp>, and its implementation has defined a
    singleton under <samp>baz</samp>, an attempt to
    access <samp>foo/bar/baz</samp> will result in that component's
    construction and temporary retention under that sub-path, all
    handled by the container's agent for that singleton.

    Similarly, if the application on the receiver's side wants to pass
    the singleton in a call or a response, it should ask the agent to
    provide it;

    the agent will provide the cached instance if it currently exists,
    or it will create and cache a new instance, and bind it to the
    right path.
  </p>

  <p>
    A family of components might be useful in a scenario such as this:
  </p>

  <pre>
type v/m [
  call start;
  call stop;
  call suspend;
  call resume;
  call identify =&gt; { id : uuid };
];

type v/m-manager [
  call create-vm =&gt; okay { handle : vm };
  call get-vm { id : uuid } =&gt; okay { handle : vm };
];</pre>

  <p>
    The VM manager could simply create an internal table of VMs,
    indexed by UUID, but the references to their receivers would
    receive anonymous paths that would be invalidated if the server
    was restarted.

    Instead, the class should define an agent to map between UUID and
    component, and place it under the right sub-path:
  </p>

  <pre>
class MyVMManager implements VMManager {
  <var>...</var>

  static final StaticIndexedAgent&lt;MyVMManager, MyVM, UUID&gt; vmAgent =
          Agent.of(MyVMManager.class,
                   VM.class,
                   UUIDDiscriminator.tolerantLower(),
                   MyVMManager::getVM);

  static final Agency agency =
    new Agency(Binding.of("vm", vmAgent));

  private MyVM getVM(UUID id) { <var>...</var> }
}

MyVMManager mgr = new MyVMManager(<var>...</var>);
presence.bind(VMManager.class, mgr, MyVMManager.agency);
</pre>

  <p>
    Provided all local implementations of <code>VM</code> are obtained
    by calling <code>MyVMManager.vmAgent.get(container, id)</code>,
    they will automatically be bound under the container's path using
    the id they were created with, such
    as <samp>foo/bar/vm/871129a8-e085-4d72-a718-c30b682460ef</samp>.
  </p>

  <p>
    The agent retains no strong references to containers or their
    components, so generated components typically remain for a period
    of seconds after creation and each use.
  </p>

  <p>
    Components can have sub-components of their own.

    As sub-components are typically implemented as inner classes, they
    can't contain static agencies or agents.

    One's options are either to hold an agent non-statically per
    container (and use it always with the same container), or to hold
    the agent statically in the top-level class.
  </p>

  <p>
    See {@link uk.ac.lancs.carp.component} for details.
  </p>


  {@h1 Future directions}

  <p>
    Union types should be implemented in a manner similar to response
    types.

    For now, a structure type with only optional fields will suffice.

    Actually, it's not clear how union types would work with
    non-structure members (which response types always are).
  </p>

  <p>
    Interface types should be able to have named and typed properties,
    and optionally support read, write and update operations,
    corresponding to GET, PUT and PATCH HTTP methods.

    Not sure how this would be expressed.

    I had a bunch of code ready, but it didn't really fit with
    inherited interfaces.
  </p>
  

  @title CARP (Call A Remote Procedure)

  @shorttitle CARP

  @group user User-facing packages

  @group dev Developer packages

  @package user uk.ac.lancs.carp

  @package user uk.ac.lancs.carp.errors

  @package user uk.ac.lancs.carp.component

  @package user uk.ac.lancs.carp.component.std

  @package user uk.ac.lancs.carp.deploy

  @package dev uk.ac.lancs.carp.map

  @package dev uk.ac.lancs.carp.syntax

  @package dev uk.ac.lancs.carp.model

  @package dev uk.ac.lancs.carp.runtime

  @package dev uk.ac.lancs.carp.model.syntax

  @package dev uk.ac.lancs.carp.model.syntax.std

  @package dev uk.ac.lancs.carp.codec

  @package dev uk.ac.lancs.carp.model.std

  @package dev uk.ac.lancs.carp.codec.std

  @see <a href="https://www.lancaster.ac.uk/~simpsons/pkg-carp">Software</a>

  @pname simpsons Steven Simpson

  @plink simpsons https://github.com/simpsonst

  @paddr simpsons School of Computing and Communications, Lancaster
  University

  @pdesc simpsons

  @aftmatter

  <div class="feature copyright">
    &copy; Lancaster University<br>

    <a href="https://www.lancaster.ac.uk/compliance/legalnotice/">Copyright
    &amp; Disclaimer</a>
  </div>

</body>
